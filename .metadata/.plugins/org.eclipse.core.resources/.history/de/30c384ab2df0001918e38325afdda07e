import java.util.ArrayList;
import java.util.List; 
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;

// Node class used for both implementations 
class Node { 
	int data; 
	Node left, right; 
	ArrayList<Node> ancestors;

	Node(int value) { 
		data = value; 
		left = right = null; 
		ancestors=null;
	} 
} 

public class LCA 
{

	Node root; //initialises root
	List<Integer> path1 = new ArrayList<>(); //creates list for node 1's path
	List<Integer> path2 = new ArrayList<>(); // creates list for node 2's path


	
	// LCA DEVELOPMENT TASK 1 - BINARY TREE IMPLEMENTATION

	
	private Node addRecursive(Node current, int value) {
		if (current == null) {
			return new Node(value);
		}

		if (value < current.data) {
			current.left = addRecursive(current.left, value);
		} else if (value > current.data) {
			current.right = addRecursive(current.right, value);
		} else {
			// value already exists
			return current;
		}

		return current;
	}

	public void add(int value) {
		root = addRecursive(root, value);
	}

	private Node deleteRecursive(Node current, int value) {
		if (current == null) {
			return current;
		}

		if (value < current.data) {
			current.left = deleteRecursive(current.left, value);
		}
		else if (value > current.data) {
			current.right = deleteRecursive(current.right, value);
		}
		else {
			if(current.left == null)
				return current.right;
			else if (current.right == null) 
				return current.left;
			current.data = findSmallestValue(root.right);
			current.right = deleteRecursive(root.right, root.data); 
		}
		return current;
	}

	private int findSmallestValue(Node root) {
		return root.left == null ? root.data : findSmallestValue(root.left);
	}

	public void delete(int value) {
		root = deleteRecursive(root, value);
		System.out.println("Node with value " + value + " has been deleted");
	}



	// Finds the path from root node to given root of the tree. 
	int findLCA(int n1, int n2) { 
		path1.clear(); 
		path2.clear(); 
		return findLCAInternal(root, n1, n2); 
	} 

	private int findLCAInternal(Node root, int n1, int n2) { 

		if (!findPath(root, n1, path1) || !findPath(root, n2, path2)) { 
			System.out.println((path1.size() > 0) ? "n1 is present" : "n1 is missing"); 
			System.out.println((path2.size() > 0) ? "n2 is present" : "n2 is missing"); 
			return -1; 
		} 

		int i; 
		for (i = 0; i < path1.size() && i < path2.size(); i++) { 

			// System.out.println(path1.get(i) + " " + path2.get(i)); 
			if (!path1.get(i).equals(path2.get(i))) 
				break; 
		} 

		return path1.get(i-1); 
	} 

	// Finds the path from root node to given root of the tree, Stores the 
	// path in a vector path[], returns true if path exists otherwise false 
	private boolean findPath(Node root, int n, List<Integer> path) 
	{ 
		// base case 
		if (root == null) { 
			return false; 
		} 

		// Store this node . The node will be removed if 
		// not in path from root to n. 
		path.add(root.data); 

		if (root.data == n) { 
			return true; 
		} 

		if (root.left != null && findPath(root.left, n, path)) { 
			return true; 
		} 

		if (root.right != null && findPath(root.right, n, path)) { 
			return true; 
		} 

		// If not present in subtree rooted with root, remove root from 
		// path[] and return false 
		path.remove(path.size()-1); 

		return false; 
	} 



	
	// LCA DEVELOPMENT TASK 2 - DIRECTED ACYCLIC GRAPH IMPLEMENTATION
	
	
	
	private int V;           // number of vertices in this digraph
	private int E;                 // number of edges in this digraph
	private ArrayList<Integer>[] adj;    // adj[v] = adjacency list for vertex v
	private int[] indegree;        // indegree[v] = indegree of vertex v
	private boolean marked[];		//Boolean List to track visited vertices
	private boolean hasCycle;		//True if cycle in graph
	private boolean stack[];		//Order that vertices were visited
	private int[] edgeTo;      // edgeTo[v] = last edge on shortest s->v path
	private int[] distTo;      // distTo[v] = length of shortest s->v path
	
	
	
	public LCA(int V)
	{
		if (V < 0) throw new IllegalArgumentException("Number of vertices in a Digraph must be nonnegative");
	    this.V = V;
	    this.E = 0;
	    indegree = new int[V];
	    marked = new boolean[V];
	    stack = new boolean[V];
	    adj = (ArrayList<Integer>[]) new ArrayList[V];
	    for (int v = 0; v < V; v++) {
	        adj[v] = new ArrayList<Integer>();
	    }              
	}

	//Returns current vertex
	public int V() {
		return V;	
	}
	
	public int E() {
        return E;
    }

	
	
	//Adds a directed edge from v->w
	public void addEdge(int v, int w)
	{
	    if((validateVertex(v)>0)&&(validateVertex(w)>0))
	    {
	    	adj[v].add(w);
	    	indegree[w]++;
	    	E++;
	    }
	    else{
	    	System.out.println("Please enter vertices between 0 & n-1");
	    }
	    	
	}
	
	private int validateVertex(int v) {
        if (v < 0 || v >= V)
        	return -1;
        else
        	return 1;}

	
	//Returns amount of directed edges incident to vertex v
	public int indegree(int v) {
		if(validateVertex(v)<0){
			return -1;
		}
		else{
			return indegree[v];
		}
	}
	
	//Returns amount of directed edges from vertex v
	public int outdegree(int v) {
		if(validateVertex(v)<0){
			return -1;
		}
		else{
			return adj[v].size();
		}
    }
		
	
	//Returns the adjacent vertices to v
	public Iterable<Integer> adj(int v)
	{ return adj[v]; }
	
	public int findLcaDag(int v, int w){
		findCycle(0);
		if(hasCycle){
			//Graph is not a DAG
			return -1;
		}
		//Reverse the dag, allows easier traversal
		LCA backwards = reverse();
		
		//Locate the two points in the graph
		ArrayList<Integer> vPath = backwards.BFS(v);
		ArrayList<Integer> wPath = backwards.BFS(w);
		ArrayList<Integer> commonAncestors = new ArrayList<Integer>();
		boolean found = false;
		
		//cycle through the BFS paths, adding all common ancestors to the arrayList
		//return the first one found, as it is the closest to the nodes.
		for(int i = 0; i<vPath.size(); i++){
				for(int t = 0; t<wPath.size(); t++){		
					if(vPath.get(i)==wPath.get(t)){
						commonAncestors.add(vPath.get(i));	
						found = true;
					}
			}
		}
		//return -1 in any case where no lca is found (empty dag etc)
		if(found)
			return commonAncestors.get(0);
		else
			return -1;
	}
	//to find the LCA, will have to traverse the graph backwards as the lca comes before the two nodes
    public LCA reverse() {
        LCA reverse = new LCA(V); //new dag of same parameter
        for (int v = 0; v < V; v++) {
            for (int w : adj(v)) {
                reverse.addEdge(w, v); //reverse the direction of the edges
            }
        }
        return reverse;
    }
    
	public ArrayList<Integer> BFS(int s)
    {
        // Mark all the vertices as not visited(By default set as false)
        boolean visited[] = new boolean[V];
 
        LinkedList<Integer> queue = new LinkedList<Integer>();
        ArrayList<Integer> order= new ArrayList<Integer>();
 
        visited[s]=true;
        queue.add(s);
        
 
        while (queue.size() != 0)
        {
            // Dequeue a vertex from queue and print it
            s = queue.poll();           
            order.add(s);
            // Get all adjacent vertices of the dequeued vertex s
            // If a adjacent has not been visited, then mark it
            // visited and enqueue it
            Iterator<Integer> i = adj[s].listIterator();
            while (i.hasNext())
            {
                int n = i.next();
                if (!visited[n])
                {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
        
        return order;
        
    }
	
	public boolean hasCycle() {

        return hasCycle;
    }
	
	 public void findCycle(int v) {

	        marked[v] = true;
	        stack[v] = true;

	        for (int w : adj(v)) {
	            if(!marked[w]) {
	                findCycle(w);
	            } else if (stack[w]) {
	                hasCycle = true;
	                return;
	            }
	        }

	        stack[v] = false;
	    }
	
}