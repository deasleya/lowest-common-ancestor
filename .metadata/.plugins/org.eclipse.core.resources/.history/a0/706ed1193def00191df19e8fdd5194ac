// TODO: IMPLEMENT LCA ON DIRECTED ACYCLIC GRAPH
import java.util.ArrayList; 
import java.util.List; 
  
// A Binary Tree node 
class Node { 
    int data; 
    Node left, right; 
  
    Node(int value) { 
        data = value; 
        left = right = null; 
    } 
} 


public class LCA <Key extends Comparable<Key>, Value> {
	
	private class Edge {
		public int u;
		public int v;
		public int w;
		
		public Edge(int u, int v, int w)
		{
			this.u=u;
			this.v=v;
			this.w=w;
		}
	}
	public ArrayList<Edge>[] adjacencyList=null;
	public int[] inEdgeCount=null;
	public int noOfVertices;

	public LCA(int noOfVertices)
	{
		adjacencyList=(ArrayList<Edge>[])new ArrayList[noOfVertices+1];
		for(int i=1;i<=noOfVertices;i++)
		{
			adjacencyList[i]=new ArrayList<Edge>();
		}
		inEdgeCount=new int[noOfVertices+1];
		this.noOfVertices=noOfVertices;
	}

	/**
	 * 
	 * @param u
	 * @param v
	 * @param w
	 * To add edges to the adjacency list graph
	 */
	public void addEdge(int u, int v, int w)
	{
		if(adjacencyList[u]==null)
			adjacencyList[u]=new ArrayList<Edge>();
		adjacencyList[u].add(new Edge(u, v, w));
	}

	/**
	 * 
	 * @param u
	 * @param v
	 * To remove the edge from the graph
	 */
	public void removeEdge(int u, int v)
	{
		int indexToBeRemoved=-1;
		ArrayList<Edge> edgeList=adjacencyList[u];
		for(int i=0;i<adjacencyList[u].size();i++)
		{
			Edge e=edgeList.get(i);
			if(e.u==u&&e.v==v)
			{
				indexToBeRemoved=i;
			}
		}
		if(indexToBeRemoved!=-1)
			edgeList.remove(indexToBeRemoved);
	}

	/**
	 * 
	 * @param u
	 * @return
	 * To return the outgoing edges for the given source
	 */
	public ArrayList<Edge> getOutEdges(int u)
	{
		return adjacencyList[u];
	}

	/**
	 * 
	 * @param u
	 * @param v
	 * @return
	 * To get the weight given the u and v values
	 * 
	 */
	public int getWeight(int u, int v)
	{
		ArrayList<Edge> edgeList=adjacencyList[u];
		int weight=0;
		for(Edge e : edgeList)
		{
			if(e.v==v)
				weight=e.w;
		}
		return weight;
	}

	/**
	 * To return the array of adjacency list(Actually the graph)
	 * @return
	 */
	public ArrayList<Edge>[] getListOfAdjacencylist()
	{
		return adjacencyList;
	}

	/**
	 * To return the count of incoming edges for each vertices in an array
	 * @return
	 */
	public int[] getInEdgesCount()
	{
		for(int i=1;i<=noOfVertices;i++)
		{
			for(int j=1;j<adjacencyList.length;j++)
			{
				ArrayList<Edge> list=adjacencyList[j];
				for(Edge e : list)
				{
					if(e.v==i)
						inEdgeCount[i]++;
				}
			}

		}
		return inEdgeCount;
	}
	
	public Key lowestCommonAncestor(int a)
	{
		return null;
	}
}



// LCA1 DEVELOPMENT TASK - BINARY TREE IMPLEMENTATION 

  
//public class LCA  
//{ 
//  
//    Node root; 
//    private List<Integer> path1 = new ArrayList<>(); 
//    private List<Integer> path2 = new ArrayList<>(); 
//    
//    private Node addRecursive(Node current, int value) {
//    	if (current == null) {
//    		return new Node(value);
//    	}
//
//    	if (value < current.data) {
//    		current.left = addRecursive(current.left, value);
//    	} else if (value > current.data) {
//    		current.right = addRecursive(current.right, value);
//    	} else {
//    		// value already exists
//    		return current;
//    	}
//
//    	return current;
//    }
//
//    public void add(int value) {
//    	root = addRecursive(root, value);
//    }
//  
//    private Node deleteRecursive(Node current, int value) {
//    	if (current == null) {
//    		return current;
//    	}
//
//    	if (value < current.data) {
//    		current.left = deleteRecursive(current.left, value);
//    	}
//    	else if (value > current.data) {
//    		current.right = deleteRecursive(current.right, value);
//    	}
//    	else {
//    		if(current.left == null)
//    			return current.right;
//    		else if (current.right == null) 
//    			return current.left;
//    		current.data = findSmallestValue(root.right);
//    		current.right = deleteRecursive(root.right, root.data); 
//    	}
//    	return current;
//    }
//
//    private int findSmallestValue(Node root) {
//    	return root.left == null ? root.data : findSmallestValue(root.left);
//    }
//
//    public void delete(int value) {
//    	root = deleteRecursive(root, value);
//    	System.out.println("Node with value " + value + " has been deleted");
//    }
//    
//    
//    
// // Finds the path from root node to given root of the tree. 
//    int findLCA(int n1, int n2) { 
//        path1.clear(); 
//        path2.clear(); 
//        return findLCAInternal(root, n1, n2); 
//    } 
//    	
//    private int findLCAInternal(Node root, int n1, int n2) { 
//  
//        if (!findPath(root, n1, path1) || !findPath(root, n2, path2)) { 
//            System.out.println((path1.size() > 0) ? "n1 is present" : "n1 is missing"); 
//            System.out.println((path2.size() > 0) ? "n2 is present" : "n2 is missing"); 
//            return -1; 
//        } 
//  
//        int i; 
//        for (i = 0; i < path1.size() && i < path2.size(); i++) { 
//              
//        // System.out.println(path1.get(i) + " " + path2.get(i)); 
//            if (!path1.get(i).equals(path2.get(i))) 
//                break; 
//        } 
//  
//        return path1.get(i-1); 
//    } 
//      
//    // Finds the path from root node to given root of the tree, Stores the 
//    // path in a vector path[], returns true if path exists otherwise false 
//    private boolean findPath(Node root, int n, List<Integer> path) 
//    { 
//        // base case 
//        if (root == null) { 
//            return false; 
//        } 
//          
//        // Store this node . The node will be removed if 
//        // not in path from root to n. 
//        path.add(root.data); 
//  
//        if (root.data == n) { 
//            return true; 
//        } 
//  
//        if (root.left != null && findPath(root.left, n, path)) { 
//            return true; 
//        } 
//  
//        if (root.right != null && findPath(root.right, n, path)) { 
//            return true; 
//        } 
//  
//        // If not present in subtree rooted with root, remove root from 
//        // path[] and return false 
//        path.remove(path.size()-1); 
//  
//        return false; 
//    } 
//}